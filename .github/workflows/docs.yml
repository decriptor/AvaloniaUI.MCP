name: Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'docs/**'
      - 'README.md'
      - 'CLAUDE.md'
      - 'src/**/*.cs'
  pull_request:
    branches: [ main ]
    paths:
      - 'docs/**'
      - 'README.md'
      - 'CLAUDE.md'
      - 'src/**/*.cs'

jobs:
  validate-docs:
    name: Validate Documentation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Install markdown linter
      run: npm install -g markdownlint-cli
      
    - name: Lint README.md
      run: |
        markdownlint README.md --config .markdownlint.json || echo "Creating default config"
        
        # Create default markdownlint config if it doesn't exist
        cat > .markdownlint.json << 'EOF'
        {
          "default": true,
          "MD013": false,
          "MD033": false,
          "MD041": false
        }
        EOF
        
        markdownlint README.md --config .markdownlint.json
        
    - name: Lint CLAUDE.md
      run: markdownlint CLAUDE.md --config .markdownlint.json
      
    - name: Check links in README
      run: |
        # Install link checker
        npm install -g markdown-link-check
        
        # Check README links
        markdown-link-check README.md --config .markdown-link-check.json || echo "Creating default link check config"
        
        # Create default link check config
        cat > .markdown-link-check.json << 'EOF'
        {
          "ignorePatterns": [
            {
              "pattern": "^http://localhost"
            },
            {
              "pattern": "^https://github.com/your-username"
            }
          ],
          "timeout": "10s",
          "retryOn429": true,
          "retryCount": 3,
          "fallbackRetryDelay": "30s"
        }
        EOF
        
        markdown-link-check README.md --config .markdown-link-check.json
        
    - name: Check documentation coverage
      run: |
        echo "Checking documentation coverage..."
        
        # Check if all public APIs are documented
        missing_docs=0
        
        # Find public classes/methods without XML docs
        while IFS= read -r -d '' file; do
          echo "Checking $file..."
          
          # Simple check for public members without XML docs
          if grep -n "public class\|public interface\|public enum" "$file" | while read -r line; do
            line_num=$(echo "$line" | cut -d: -f1)
            prev_line=$((line_num - 1))
            
            if [ $prev_line -gt 0 ]; then
              prev_content=$(sed -n "${prev_line}p" "$file")
              if [[ ! "$prev_content" =~ \/\/\/ ]]; then
                echo "Missing documentation: $file:$line_num"
                missing_docs=$((missing_docs + 1))
              fi
            fi
          done
        done < <(find src -name "*.cs" -print0)
        
        if [ $missing_docs -gt 0 ]; then
          echo "⚠️ Found $missing_docs public members without documentation"
        else
          echo "✅ All public APIs are documented"
        fi

  generate-api-docs:
    name: Generate API Documentation
    runs-on: ubuntu-latest
    needs: validate-docs
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.300'
        
    - name: Install DocFX
      run: dotnet tool install -g docfx
      
    - name: Create DocFX config
      run: |
        mkdir -p docs
        
        cat > docs/docfx.json << 'EOF'
        {
          "metadata": [
            {
              "src": [
                {
                  "files": ["src/**/*.csproj"],
                  "src": ".."
                }
              ],
              "dest": "api",
              "includePrivateMembers": false,
              "disableGitFeatures": false,
              "disableDefaultFilter": false,
              "noRestore": false,
              "namespaceLayout": "flattened",
              "memberLayout": "samePage"
            }
          ],
          "build": {
            "content": [
              {
                "files": ["api/**.yml", "api/index.md"]
              },
              {
                "files": ["**.md"],
                "src": "..",
                "dest": "."
              }
            ],
            "resource": [
              {
                "files": ["images/**"]
              }
            ],
            "dest": "_site",
            "globalMetadataFiles": [],
            "fileMetadataFiles": [],
            "template": ["default"],
            "postProcessors": [],
            "markdownEngineName": "markdig",
            "noLangKeyword": false,
            "keepFileLink": false,
            "cleanupCacheHistory": false,
            "disableGitFeatures": false,
            "globalMetadata": {
              "_appTitle": "AvaloniaUI MCP Server",
              "_appFooter": "AvaloniaUI MCP Server Documentation",
              "_enableSearch": true
            }
          }
        }
        EOF
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Generate documentation
      run: |
        cd docs
        docfx docfx.json --serve false
        
    - name: Upload documentation artifacts
      uses: actions/upload-artifact@v4
      with:
        name: api-documentation
        path: docs/_site/
        retention-days: 30

  deploy-docs:
    name: Deploy Documentation
    runs-on: ubuntu-latest
    needs: generate-api-docs
    if: github.ref == 'refs/heads/main'
    permissions:
      pages: write
      id-token: write
      
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
      
    steps:
    - name: Download documentation
      uses: actions/download-artifact@v4
      with:
        name: api-documentation
        path: docs-site/
        
    - name: Setup Pages
      uses: actions/configure-pages@v4
      
    - name: Upload to GitHub Pages
      uses: actions/upload-pages-artifact@v3
      with:
        path: docs-site/
        
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4

  update-docs:
    name: Update Documentation
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.300'
        
    - name: Generate MCP capabilities documentation
      run: |
        # Create a script to extract MCP capabilities
        cat > extract-capabilities.py << 'EOF'
        import json
        import os
        import re
        from pathlib import Path
        
        def extract_tools():
            tools = []
            tools_dir = Path("src/AvaloniaUI.MCP/Tools")
            
            for cs_file in tools_dir.glob("*.cs"):
                content = cs_file.read_text()
                
                # Extract tool methods
                tool_pattern = r'\[McpServerTool.*?\]\s*(?:\[Description\("([^"]+)"\)\s*)?public static[^{]*?\s+(\w+)\s*\('
                matches = re.finditer(tool_pattern, content, re.DOTALL)
                
                for match in matches:
                    description = match.group(1) if match.group(1) else "No description"
                    method_name = match.group(2)
                    tools.append({
                        "name": method_name,
                        "description": description,
                        "file": str(cs_file.name)
                    })
            
            return tools
        
        def extract_resources():
            resources = []
            resources_dir = Path("src/AvaloniaUI.MCP/Resources")
            
            for cs_file in resources_dir.glob("*.cs"):
                content = cs_file.read_text()
                
                # Extract resource methods
                resource_pattern = r'\[McpServerResource.*?\]\s*(?:\[Description\("([^"]+)"\)\s*)?public static[^{]*?\s+(\w+)\s*\('
                matches = re.finditer(resource_pattern, content, re.DOTALL)
                
                for match in matches:
                    description = match.group(1) if match.group(1) else "No description"
                    method_name = match.group(2)
                    resources.append({
                        "name": method_name,
                        "description": description,
                        "file": str(cs_file.name)
                    })
            
            return resources
        
        def extract_prompts():
            prompts = []
            prompts_dir = Path("src/AvaloniaUI.MCP/Prompts")
            
            for cs_file in prompts_dir.glob("*.cs"):
                content = cs_file.read_text()
                
                # Extract prompt methods
                prompt_pattern = r'\[McpServerPrompt.*?\]\s*(?:\[Description\("([^"]+)"\)\s*)?public static[^{]*?\s+(\w+)\s*\('
                matches = re.finditer(prompt_pattern, content, re.DOTALL)
                
                for match in matches:
                    description = match.group(1) if match.group(1) else "No description"
                    method_name = match.group(2)
                    prompts.append({
                        "name": method_name,
                        "description": description,
                        "file": str(cs_file.name)
                    })
            
            return prompts
        
        # Extract capabilities
        tools = extract_tools()
        resources = extract_resources()
        prompts = extract_prompts()
        
        # Generate markdown
        markdown = """# MCP Server Capabilities
        
        This document is auto-generated from the source code and lists all available capabilities.
        
        ## Tools (Actions)
        
        """
        
        for tool in tools:
            markdown += f"### {tool['name']}\n"
            markdown += f"**Description**: {tool['description']}\n"
            markdown += f"**Source**: {tool['file']}\n\n"
        
        markdown += "\n## Resources (Knowledge Base)\n\n"
        
        for resource in resources:
            markdown += f"### {resource['name']}\n"
            markdown += f"**Description**: {resource['description']}\n"
            markdown += f"**Source**: {resource['file']}\n\n"
        
        markdown += "\n## Prompts (Templates)\n\n"
        
        for prompt in prompts:
            markdown += f"### {prompt['name']}\n"
            markdown += f"**Description**: {prompt['description']}\n"
            markdown += f"**Source**: {prompt['file']}\n\n"
        
        # Write to file
        with open("docs/CAPABILITIES.md", "w") as f:
            f.write(markdown)
        
        print(f"Generated documentation for {len(tools)} tools, {len(resources)} resources, and {len(prompts)} prompts")
        EOF
        
        python3 extract-capabilities.py
        
    - name: Check for documentation changes
      id: check-changes
      run: |
        if git diff --quiet docs/CAPABILITIES.md; then
          echo "changes=false" >> $GITHUB_OUTPUT
        else
          echo "changes=true" >> $GITHUB_OUTPUT
        fi
        
    - name: Commit documentation updates
      if: steps.check-changes.outputs.changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add docs/CAPABILITIES.md
        git commit -m "docs: auto-update MCP capabilities documentation"
        git push